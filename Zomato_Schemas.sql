-- Analysis based on 
	-- 1. Aggregation and Grouping
    -- 2. Joins and Relationships
    -- 3. Subqueries and CTEs
    -- 4. Advanced SQL Functions
-- 1Q . Find the customer who placed order more  than average number of orders , also return the name of the customers and their order count
use zomato_db;

SELECT c.customer_name, n.customer_id, n.total_orders
FROM customers AS c
INNER JOIN (
    SELECT customer_id, COUNT(order_id) AS total_orders -- subquery to find the customer_id and more than average orders of total number of orders
    FROM Orders
    GROUP BY customer_id
    HAVING COUNT(order_id) > (
        SELECT AVG(order_count) 
        FROM (
            SELECT COUNT(order_id) AS order_count
            FROM Orders
            GROUP BY customer_id
        ) AS customer_orders
    )
) AS n ON c.customer_id = n.customer_id;
-- average number of order is 416.66 , these custoners order more number of times than average of all the cutomers 


-- 2Q . Find the customer who spent  more  than 2 lakh in total , also return the name of the customers and their total spending

SELECT c.customer_name, c.customer_id, SUM(o.total_amount) AS total_spent
FROM customers AS c
INNER JOIN orders AS o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.customer_name
HAVING total_spent > 200000;

-- 3Q. Find the number of orders which was not delivered , also give the restaurant name and city and number of orders not delivered. 

SELECT 
	r.restaurant_name,
    r.city,
	COUNT(*) AS orders_not_delivered
FROM orders as o
LEFT JOIN 
restaurants as r
ON r.restaurant_id = o.restaurant_id
WHERE 
	o.order_id NOT IN (SELECT order_id FROM deliveries)
GROUP BY r.restaurant_name,r.city
ORDER BY orders_not_delivered DESC;

-- 4Q. Most Popular Dish by City: 
-- Identify the most popular dish in each city based on the number of orders.

SELECT * 
FROM
(SELECT 
	r.city,
	o.order_item as dish,
	COUNT(order_id) as total_orders,
	RANK() OVER(PARTITION BY r.city ORDER BY COUNT(order_id) DESC) as rank_by_dish
FROM orders as o
JOIN 
restaurants as r
ON r.restaurant_id = o.restaurant_id
GROUP BY r.city, dish
) as t1
WHERE rank_by_dish = 1;

-- 5Q. Rank each city based on the total revenue for last year 2023 

SELECT 
	r.city,
	SUM(total_amount) as total_revenue,
	RANK() OVER(ORDER BY SUM(total_amount) DESC) as city_rank
FROM orders as o
JOIN
restaurants as r
ON o.restaurant_id = r.restaurant_id
GROUP BY r.city;

-- Q.6  Order Item Popularity: 
-- Track the popularity of specific order items over time and identify seasonal demand spikes.

SELECT 
	order_item,
	seasons,
	COUNT(order_id) as total_orders
FROM 
(
SELECT 
		*,
		EXTRACT(MONTH FROM order_date) as month,
		CASE 
			WHEN EXTRACT(MONTH FROM order_date) BETWEEN 3 AND 4 THEN 'Spring'
			WHEN EXTRACT(MONTH FROM order_date) BETWEEN 5 AND 6 THEN 'Summer'
            WHEN EXTRACT(MONTH FROM order_date) BETWEEN 7 AND 9 THEN 'Monsoon'
            WHEN EXTRACT(MONTH FROM order_date) BETWEEN 10 AND 11 THEN 'Post-monsoon'
			ELSE 'Winter'
		END as seasons
	FROM orders
) as t
GROUP BY order_item, seasons
ORDER BY seasons, total_orders DESC;

-- Q7. Calculate the total revenue generated by each customer over all their orders and create a customer type based on their total spending
SELECT 
*,
CASE 
			WHEN  total_spending > 250000  THEN 'Platinum Member'
			WHEN total_spending > 200000  THEN 'Gold Member'
            WHEN total_spending > 150000  THEN 'Silver Member'
			ELSE 'Normal Member'
		END AS customer_type
FROM 
(SELECT 
	o.customer_id,
	c.customer_name,
	SUM(o.total_amount) as total_spending
FROM orders as o
JOIN customers as c
ON o.customer_id = c.customer_id
GROUP BY o.customer_id, c.customer_name) AS t;

-- Q8. Order Frequency by Day for each restaurant ,it give the busiest day for the reaturant 


SELECT * FROM
(
	SELECT 
		r.restaurant_name,
		DAYNAME(o.order_date) AS day_of_week,
		COUNT(o.order_id) as total_orders,
		DENSE_RANK() OVER(PARTITION BY r.restaurant_name ORDER BY COUNT(o.order_id)  DESC) as rank_by_order
	FROM orders as o
	JOIN
	restaurants as r
	ON o.restaurant_id = r.restaurant_id
	GROUP BY 1, 2
	ORDER BY 1, 3 DESC
	) as t1
WHERE rank_by_order = 1;

-- Q9. Rider Monthly Earnings assuming they earn 5% of the order amount.


SELECT 
	d.rider_id,
	DATE_FORMAT(o.order_date, '%m-%y') AS month,
	SUM(total_amount) as revenue,
	ROUND(SUM(total_amount)* 0.05,0) as riders_earning
FROM orders as o
JOIN deliveries as d
ON o.order_id = d.order_id
GROUP BY d.rider_id, month
ORDER BY d.rider_id, month;

